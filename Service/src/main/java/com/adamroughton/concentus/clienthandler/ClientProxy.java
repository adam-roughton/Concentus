/*
 * Copyright 2013 Adam Roughton
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.adamroughton.concentus.clienthandler;

import com.adamroughton.concentus.util.SlidingWindowLongMap;

public class ClientProxy {

	private final long _clientId;
	private byte[] _clientSocketId;
	private long _lastMsgTime;
	private long _lastUpdateId;
	
	private boolean _isActive;
	
	/**
	 * Store the last 128 input actions -> client action ID mappings for this client
	 */
	private final SlidingWindowLongMap _actionIdMap = new SlidingWindowLongMap(128);
	
	public ClientProxy(final long clientId) {
		_clientId = clientId;
		_lastMsgTime = 0;
		_clientSocketId = new byte[0];
		_lastUpdateId = -1;
		_isActive = false;
	}
	
	public boolean isActive() {
		return _isActive;
	}
	
	public void setIsActive(boolean isActive) {
		_isActive = isActive;
	}
	
	public long getClientId() {
		return _clientId;
	}
	
	public void setSocketId(byte[] socketIdBytes) {
		setSocketId(socketIdBytes, 0, socketIdBytes.length);
	}
	
	public void setSocketId(byte[] socketIdBytes, int offset, int length) {
		if (_clientSocketId.length < length) {
			_clientSocketId = new byte[length];
		}
		System.arraycopy(socketIdBytes, offset, _clientSocketId, 0, length);
	}
	
	public void writeSocketId(byte[] buffer, int offset) {
		System.arraycopy(_clientSocketId, 0, buffer, offset, _clientSocketId.length);
	}
	
	public byte[] getSocketId() {
		byte[] clientSocketId = new byte[_clientSocketId.length];
		System.arraycopy(_clientSocketId, 0, clientSocketId, 0, _clientSocketId.length);
		return clientSocketId;
	}
	
	public long getLastMsgTime() {
		return _lastMsgTime;
	}
	
	public void setLastMsgTime(final long msgTime) {
		_lastMsgTime = msgTime;
	}
	
	public long getLastUpdateId() {
		return _lastUpdateId;
	}
	
	public void setLastUpdateId(final long updateId) {
		_lastUpdateId = updateId;
	}
	
	/**
	 * Searches for the highest client action ID that the given
	 * {@code clientHandlerInputId} is associated with. When client input
	 * events are forwarded onto the canonical state processor, a
	 * link is created that matches the emitted <i>client handler input
	 * ID</i> and the originating <i>client input ID</i>. This allows the
	 * client handler to get the highest client input action that has been
	 * processed as part of the update.
	 * @param clientHandlerInputId the ID of the client handler action
	 * @return the highest associated client input action, or {@code -1} if
	 * no actions have been generated by the client
	 */
	public long lookupActionId(long clientHandlerInputId) {
		long headActionId = _actionIdMap.getHeadIndex();
		if (headActionId > 0) {
			long tailActionId = headActionId - _actionIdMap.windowSize() + 1;
			tailActionId = (tailActionId < 0)? 0: tailActionId;	
			return binarySearchHighestMatch(_actionIdMap, clientHandlerInputId, tailActionId, headActionId);
		}
		return -1;
	}
	
	private static long binarySearchHighestMatch(SlidingWindowLongMap window, long key, long startIndex, long endIndex) {
		if (startIndex > endIndex) {
			return -1;
		} 
		long midIndex = startIndex + (endIndex - startIndex) / 2;
		long midValue = window.get(midIndex);
		if (midValue == key) {
			return key;
		} else if (midValue < key) {
			long nextHighestMatch = binarySearchHighestMatch(window, key, midIndex + 1, endIndex);
			if (nextHighestMatch == -1) {
				return midValue;
			} else {
				return nextHighestMatch;
			}
		} else {
			return binarySearchHighestMatch(window, key, startIndex, midIndex - 1);
		}
	}
	
	public void storeAssociation(long actionId, long clientHandlerInputId) {
		_actionIdMap.put(actionId, clientHandlerInputId);
	}
	
}
